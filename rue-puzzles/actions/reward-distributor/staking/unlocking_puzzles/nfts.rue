// nfts.rue by yakuhito
// Sends a given set of staked NFTs back to the user.

// This is an unlocking puzzle - output is (unlocked_shares . output_conditions).
// Ephemeral_State & Entry_Custody_Puzzle_Hash are Truths verified and passed by 'stake.clsp'.

import super::unstake::UnlockPuzzleOutput;

struct NftInfo {
    nft_launcher_id: Bytes32,
    nft_parent_id: Bytes32,
    nft_metadata_hash: Bytes32,
    nft_metadata_updater_hash_hash: Bytes32,
    nft_owner: Bytes32,
    nft_transfer_porgram_hash: Bytes32,
    ...nft_shares: Int,
}

struct NftsUnlockingPuzzleArgs {
    SINGLETON_MOD_HASH: Bytes32,
    SINGLETON_LAUNCHER_HASH: Bytes32,
    NFT_STATE_LAYER_MOD_HASH: Bytes32,
    NFT_OWNERSHIP_LAYER_MOD_HASH: Bytes32,
    NONCE_MOD_HASH: Bytes32,
    MY_P2_PUZZLE_HASH: Bytes32,
    Ephemeral_State: Int,
    Entry_Custody_Puzzle_Hash: Bytes32,
    ...nfts_to_unlock: List<NftInfo>,
}

fn create_coin_1_with_hint(ph: Bytes32) -> Condition {
    CreateCoin {
        puzzle_hash: ph,
        amount: 1,
        memos: Memos { value: [ph] },
    }
}

fn remove_nfts(
    {
        SINGLETON_MOD_HASH,
        SINGLETON_LAUNCHER_HASH,
        NFT_STATE_LAYER_MOD_HASH,
        NFT_OWNERSHIP_LAYER_MOD_HASH,
        NONCE_MOD_HASH,
        MY_P2_PUZZLE_HASH,
        Entry_Custody_Puzzle_Hash,
        ...args,
    }: NftsUnlockingPuzzleArgs,
    nfts_to_unlock: List<NftInfo>,
    shares_so_far: Int,
    conditions_so_far: List<Condition>,
) -> UnlockPuzzleOutput {
    if nfts_to_unlock is nil {
        UnlockPuzzleOutput {
            shares_to_remove: shares_so_far,
            unlock_conditions: conditions_so_far,
        }
    } else {
        inline let {
            nft_launcher_id,
            nft_parent_id,
            nft_metadata_hash,
            nft_metadata_updater_hash_hash,
            nft_owner,
            nft_transfer_porgram_hash,
            nft_shares,
        } = nfts_to_unlock.first;

        let delegated_puzzle_hash = tree_hash(
            // 1 is the leading 'q . ' in the delegated puzzle
            (1, [create_coin_1_with_hint(Entry_Custody_Puzzle_Hash)])
        );

        let locked_nft_inner_puzzle_hash = curry_tree_hash(
            NFT_STATE_LAYER_MOD_HASH,
            [
                tree_hash_atom(NFT_STATE_LAYER_MOD_HASH),
                nft_metadata_hash,
                nft_metadata_updater_hash_hash,
                curry_tree_hash(
                    NFT_OWNERSHIP_LAYER_MOD_HASH,
                    [
                        tree_hash_atom(NFT_OWNERSHIP_LAYER_MOD_HASH),
                        tree_hash_atom(nft_owner),
                        nft_transfer_porgram_hash,
                        curry_tree_hash(NONCE_MOD_HASH, [
                            tree_hash((Entry_Custody_Puzzle_Hash, nft_shares)),
                            MY_P2_PUZZLE_HASH,
                        ]),
                    ]
                ),
            ]
        );
        let locked_nft_coin_id = coinid(
            nft_parent_id,
            curry_tree_hash(
                SINGLETON_MOD_HASH,
                [
                    tree_hash((SINGLETON_MOD_HASH, (nft_launcher_id, SINGLETON_LAUNCHER_HASH))),
                    locked_nft_inner_puzzle_hash,
                ]
            ),
            1,
        );
        
        let new_conditions_so_far = [
            // remove entry / unlock NFT
            SendMessage {
                mode: 23, // sender puzzle hash, receiver coin id
                message: delegated_puzzle_hash,
                receiver: [locked_nft_coin_id]
            },
            // owner actually wants us to remove this entry
            ReceiveMessage {
                mode: 18, // puzzle-puzzle
                message: "u" + nft_launcher_id,
                sender: [Entry_Custody_Puzzle_Hash],
            },
            ...conditions_so_far,
        ];

        remove_nfts(
            args,
            nfts_to_unlock.rest,
            shares_so_far + nft_shares,
            new_conditions_so_far,
        )
    }
}

export fn main(
    ...args: NftsUnlockingPuzzleArgs,
) -> UnlockPuzzleOutput {
    remove_nfts(args, args.nfts_to_unlock, 0, [])
}