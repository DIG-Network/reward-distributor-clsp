// stake.rue by yakuhito
// Stakes some assets to receive active shares in return. Locking logic is
//   enforced by a LOCKING_PUZZLE, which is provided at distributor launch
//   based on its desired behavior (e.g., NFT distributor)

// Note: New entries may optionally be consolidated into one slot. To do that,
//   the old slot's cumulative payout will need to 'catch up' to the current
//   cumulative_payout. It's expected that the custody puzzle will trigger a
//   payout (by calling the initiate_payout action separately, if possible)
//   and then only give up rewards with an amount lower than the minimum payout.
//   To prevent malicious actors from exploiting this behavior,
//   consolidating an existing slot requires the custody puzzle hash to send
//   a message to the distributor with the difference it gives up (with
//   mojos * PRECISION as unit). The freed rewards will be distributed to
//   all stakers later (they're moved to remaining_rewards).


import super::super::reward_distributor::*;
import super::super::slot::*;

struct LockPuzzleOutput {
    newly_locked_shares: Int,
    ...locking_conditions: List<Condition>,
}
type LockPuzzleSolution = Any;
type LockPuzzle = fn(ephemeral_State: Int, entry_custody_puzzle_hash: Bytes32, ...solution: LockPuzzleSolution) -> LockPuzzleOutput;

export fn main(
    ENTRY_SLOT_1ST_CURRY_HASH: Bytes32, // after 1st curry
    MAX_SECONDS_OFFSET: Int, // at most this amount of seconds can pass since last update
    // /\ this prevents someone from 'stealing' earned rewards before MAX_SECONDS_OFFSET by
    //    staking a bunch of NFTs after long periods of non-sync
    LOCK_PUZZLE: LockPuzzle, // the puzzle used to enforce asset locking (CAT/NFTs)
    Truth: RewardDistributorStateTruth,
    lock_puzzle_solution: LockPuzzleSolution,
    ...{
        payout_puzzle_hash: entry_custody_puzzle_hash,
        initial_cumulative_payout: existing_slot_cumulative_payout,
        shares: existing_slot_shares,
        ...existing_slot_value
    }: EntrySlotValue,
) -> (RewardDistributorStateTruth, List<Condition>) {
    let {
        newly_locked_shares,
        locking_conditions
    } = LOCK_PUZZLE(
        Truth.Ephemeral_State,
        entry_custody_puzzle_hash,
        ...lock_puzzle_solution,
    );

    // if there is no existing slot being used, existing_slot_shares is enforced to be 0
    let remaining_rewards_delta =
        existing_slot_shares * (Truth.State.reward_info.cumulative_payout - existing_slot_cumulative_payout);

    let created_slot_value_hash = tree_hash(EntrySlotValue {
        payout_puzzle_hash: entry_custody_puzzle_hash,
        initial_cumulative_payout: Truth.State.reward_info.cumulative_payout,
        shares: existing_slot_shares + newly_locked_shares,
    });

    let base_conditions = if existing_slot_cumulative_payout > -1 {
        [
            // receive message that giving up rewards is ok
            ReceiveMessage {
                mode: 18, // puzzle-puzzle
                message: "s" + tree_hash_atom(remaining_rewards_delta as Bytes),
                sender: [
                    entry_custody_puzzle_hash,
                ],
            },
            // spend current slot
            spend_slot(
                ENTRY_SLOT_1ST_CURRY_HASH,
                tree_hash(existing_slot_value),
            ),
            ...locking_conditions,
        ]
    } else {
        assert existing_slot_shares == 0;
        locking_conditions
    };

    (RewardDistributorStateTruth {
        Ephemeral_State: Truth.Ephemeral_State + 1,
        State: RewardDistributorState {
            total_reserves: Truth.State.total_reserves,
            active_shares: Truth.State.active_shares + newly_locked_shares,
            reward_info: RewardInfo {
                cumulative_payout: Truth.State.reward_info.cumulative_payout,
                remaining_rewards: Truth.State.reward_info.remaining_rewards + remaining_rewards_delta,
            },
            round_time_info: Truth.State.round_time_info,
        },
    }, [
        create_slot_with_hint(
            ENTRY_SLOT_1ST_CURRY_HASH,
            created_slot_value_hash,
            entry_custody_puzzle_hash,
        ),
        CreatePuzzleAnnouncement {
            message: "t" + created_slot_value_hash,
        },
        // make sure the reward info is up to date
        AssertBeforeSecondsAbsolute {
            seconds: Truth.State.round_time_info.last_update + MAX_SECONDS_OFFSET,
        },
        ...base_conditions,
    ])
}
