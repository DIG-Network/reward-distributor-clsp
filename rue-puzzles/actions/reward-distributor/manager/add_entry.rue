// add_entry.rue by yakuhito
// Adds a reward entry to the reward distributor. The entry starts accumulating rewards right away.

import super::super::super::reward_distributor::*;
import super::super::super::slot::*;

export fn main(
    SINGLETON_MOD_HASH: Bytes32,
    MANAGER_SINGLETON_STRUCT_HASH: Bytes32, // (sha256 SINGLETON_STRUCT) for manager singleton
    ENTRY_SLOT_1ST_CURRY_HASH: Bytes32,
    MAX_SECONDS_OFFSET: Int, // at most this amount of seconds can pass since last update
    // /\ this prevents the reward distributor from 'stealing' earned rewards before MAX_SECONDS_OFFSET by
    //    adding a mirror with a gazillion shares during long periods of non-sync
    Truth: RewardDistributorStateTruth,
    entry_payout_puzzle_hash: Bytes32,
    entry_shares: Int,
    ...manager_singleton_inner_puzzle_hash: Bytes32,
) -> (RewardDistributorStateTruth, List<Condition>) {
    let manager_puzzle_hash = curry_tree_hash(SINGLETON_MOD_HASH, [
        MANAGER_SINGLETON_STRUCT_HASH,
        manager_singleton_inner_puzzle_hash,
    ]);

    (RewardDistributorStateTruth {
        Ephemeral_State: Truth.Ephemeral_State,
        State: RewardDistributorState {
            total_reserves: Truth.State.total_reserves,
            active_shares: Truth.State.active_shares + entry_shares,
            reward_info: Truth.State.reward_info,
            round_time_info: Truth.State.round_time_info,
        },
    }, [
        // manager actually wants us to add this entry
        ReceiveMessage {
            mode: 18, // puzzle hash - puzzle hash
            message: "a" + tree_hash_pair(
                tree_hash_atom(entry_payout_puzzle_hash),
                tree_hash_atom(entry_shares as Bytes),
            ),
            sender: [
                manager_puzzle_hash,
            ],
        },

        create_slot_with_hint(
            ENTRY_SLOT_1ST_CURRY_HASH,
            slot_value_hash(
                entry_payout_puzzle_hash,
                Truth.State.reward_info.cumulative_payout as Bytes,
                entry_shares as Bytes,
            ),
            entry_payout_puzzle_hash,
        ),

        // make sure the reward info is up to date
        AssertBeforeSecondsAbsolute {
            seconds: Truth.State.round_time_info.last_update + MAX_SECONDS_OFFSET,
        },
    ])
}
